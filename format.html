<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="base-min.css" rel="stylesheet"/>
<link href="style.css" rel="stylesheet"/>
<title>TIP Format</title>
</head>
<body>
<div class="header">
<h1>TIP Format</h1>
</div>
<div class="content">
<p>This document contains the <a href="index.html">TIP</a> format, which is an extension of <a href="http://smt-lib.org">SMT-LIB</a> for expression inductive problems. The grammar of the format can also be viewed as <a href="bnf.html">BNF</a>.</p>
<h3 id="scope-of-the-benchmark-suite">Scope of the benchmark suite</h3>
<p>We want the benchmark suite to focus exclusively on problems that need induction. Functional programs that don’t use inductive data types probably fit better elsewhere. Also, although we support higher-order functions and quantification over functions, problems that need a lot of higher-order reasoning (e.g. synthesis of functions) are probably better suited for THF.</p>
<h3 id="criteria">Criteria</h3>
<p>When designing our language extensions, we had these criteria in mind:</p>
<ol type="1">
<li>The problem format should not look like an encoding: features such as data types and pattern matching should be supported natively rather than encoded. We should preserve as much information as possible from the input problem in case it’s useful to a prover.</li>
<li>As far as possible, the syntax should be compatible with SMT-LIB. So we do not introduce new features just for the sake of it. We are however incompatible with SMT-LIB whenever it’s needed to avoid breaking the first criterion.</li>
<li>The format should be accessible: easy to understand and easy for other tools to use. We have written a tool which removes some of the advanced features (such as higher-order functions) from problems to help provers that don’t support those features.</li>
</ol>
<h3 id="differences-between-tip-and-smt-lib-2.6">Differences between TIP and SMT-LIB 2.6</h3>
<p>Our ambition is to keep TIP as close to SMT-LIB as possible. However, there are still a few incompatibilities:</p>
<ul>
<li>TIP allows polymorphism and type variables in function definitions. SMT-LIB does only allow polymorphism in datatype definitions.</li>
<li>TIP allows higher-order functions, while SMT-LIB does not.</li>
<li>TIP allows partial functions. SMT-LIB does not.</li>
<li>For convenience, TIP has a special command <code>prove</code> for stating a goal to prove. This allows us to state several subgoals to be proved as separate proof attempts, in one file.</li>
<li>The same syntax for annotations as in SMT-LIB is used, but TIP allow annotations to be attached to arbitrary constructs, unlike SMT-LIB.</li>
</ul>
<p>We provide translation tools to convert TIP files not compatible with SMT-LIB 2.6 to valid SMT-LIB syntax (use the command <code>tip --smtlib myTIPfile.smt2</code>). This includes monomorphisation to remove type variables, removal of lambdas, completion of partial functions, removal of annotations and a translation pass which remove the <code>prove</code> statement and replaces them with valid SMT-LIB syntax using push/pop.</p>
<h3 id="example-datatypes-match-expressions-and-recursion">Example: Datatypes, match-expressions and recursion</h3>
<p>This example specifies the commutativity of plus over natural numbers:</p>
<pre><code>(declare-datatype Nat ((Zero) (Succ (pred Nat))))
(define-fun-rec
  plus
  ((x Nat) (y Nat)) Nat
  (match x
    ((Zero y)
     ((Succ n) (Succ (plus n y))))))
(prove (forall ((n Nat) (m Nat)) (= (plus n m) (plus m n))))</code></pre>
<p>The syntax should be familiar to users of SMT-LIB. Natural numbers are defined with <code>declare-datatypes</code>. This is not in the SMT-LIB standard, but is accepted by many SMT solvers, including Z3 and CVC4.</p>
<p>The function is declared using <code>define-fun-rec</code> as in the <a href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.6-r2017-07-18.pdf">SMT-LIB v2.6 standard</a>. We define <code>plus</code> rather than axiomatising it because, if the problem is from a functional program, we want to be explicit about which axioms are function definitions.</p>
<p>The <code>match</code> expression is our proposed extension for match-expressions. The first argument to match is the scrutinee, followed by a list of branches.</p>
<p>TIP also allows the user to define their functions in a more traditional SMT-LIB syntax, using if-then-else with discriminator and projector functions (in this case <code>is-Nat</code> and <code>pred</code>). The TIP tool is able to translate between these syntaxes. Here is how the example above looks with match removed:</p>
<pre><code>(declare-datatype Nat ((Zero) (Succ (pred Nat))))
(define-fun-rec
  plus
  ((x Nat) (y Nat)) Nat (ite (is-Succ x) (Succ (plus (pred x) y)) y))
(prove (forall ((n Nat) (m Nat)) (= (plus n m) (plus m n))))</code></pre>
<p>Match expressions can also have a default branch which matches all other pattern than those explicitly listed. This is sometimes useful when there are many constructors. However, in the example above, either of the patterns <code>Zero</code> or <code>(Succ n)</code> can be replaced with the deafult symbol <code>_</code>. As an example, this is how it looks with the <code>Succ</code> case transformed:</p>
<pre><code>(declare-datatype Nat ((Zero) (Succ (pred Nat))))
(define-fun-rec
  plus
  ((x Nat) (y Nat)) Nat
  (match x
    ((_ (Succ (plus (pred x) y)))
     (Zero y))))
(prove (forall ((n Nat) (m Nat)) (= (plus n m) (plus m n))))</code></pre>
<p>Some provers like to distinguish between axioms and conjectures, and in many inductive problems we have a distinguished conjecture. Following our principle not to throw away information from the input problem, TIP has a <code>prove</code> construct which identifies the goal, akin to <code>conjecture</code> in TPTP, or <code>goal</code> in Why3. The declaration <code>(prove p)</code> means the same as <code>(assert (not p))</code>, except that it marks <code>p</code> as a goal. It can easily be removed by the TIP tool:</p>
<pre><code>(declare-datatype Nat ((Zero) (Succ (pred Nat))))
(define-fun-rec
  plus
  ((x Nat) (y Nat)) Nat
  (match x
    ((Zero y)
     ((Succ n) (Succ (plus n y))))))
(assert (not (forall ((n Nat) (m Nat)) (= (plus n m) (plus m n)))))</code></pre>
<p>The tool can also translate the example to Why3 syntax. It then looks like this:</p>
<pre><code>module A
  use HighOrd
  use import int.Int
  use import int.EuclideanDivision
  use import real.RealInfix
  use import real.FromInt
  type nat = Zero | Succ (nat)
  function plus (x : nat) (y : nat) : nat =
    match x with
      | Zero -&gt; y
      | Succ n -&gt; Succ (plus n y)
    end
  (* plus (Zero) y = y
     plus (Succ n) y = Succ (plus n y) *)
  goal x0 : forall n : nat, m : nat . (plus n m) = (plus m n)
end</code></pre>
<!--

### Complaints

(Data type declarations are already parametric, but the syntax is a bit broken.
It does not support declaring mutually recursive datatypes that differ in the amount of
type arguments.)

It is a bit broken because you have to first define all the signatures, and then the bodies.

-->
<h3 id="example-polymorphism">Example: Polymorphism</h3>
<p>TIP also supports polymorphism. Here is an example showing the right identity of append over polymorphic lists:</p>
<pre><code>(declare-datatype
  list (par (a) ((nil) (cons (head a) (tail (list a))))))
(define-fun-rec
  append
  (par (a) (((xs (list a)) (ys (list a))) (list a)))
  (match xs
    ((nil (_ nil a))
     ((cons x zs) (cons x (append zs ys))))))
(prove
  (par (a) (forall ((xs (list a))) (= (append xs (_ nil a)) xs))))</code></pre>
<p>We allow polymorphic datatypes, declarations and assertions using the syntactic form <code>(par (A) ...)</code> to quantify over the type variable <code>A</code>. Only rank-1 polymorphism is supported. Note that TIP allows both polymorphic datatypes and polymorphic functions, unlike SMT-LIB 2.6, which only allows it in datatype definitions.</p>
<!--
suggested in @smtlam, which is currently waiting to be merged
into CVC4 (@cvc4parPR). This syntax uses the syntactic form
`(par (A) ...)` to quantify over the type variable `A`. Only rank-1
polymorphism is supported.
-->
<p>Expressions can be annotated with their type with the <code>as</code> keyword. When the type of a function application is not fully specified by only looking the types of its arguments, the problem must use <code>as</code> to specify the type.</p>
<p>Polymorphism can be removed by specialising the program at some ground types, but this is not necessarily complete. Another method is to encode typing information over monomorphic terms. We plan to add techniques for this to the TIP toolchain. For now, provers must natively support polymorphism if they want to solve polymorphic problems.</p>
<p>When translating <code>assert-not</code> into <code>assert</code>, any polymorphic type variables are Skolemised:</p>
<pre><code>(declare-sort sk :skolem 0)
(declare-datatype
  list (par (a) ((nil) (cons (head a) (tail (list a))))))
(define-fun-rec
  append
  (par (a) (((xs (list a)) (ys (list a))) (list a)))
  (match xs
    ((nil (_ nil a))
     ((cons x zs) (cons x (append zs ys))))))
(assert
  (not (forall ((xs (list sk))) (= (append xs (_ nil sk)) xs))))</code></pre>
<p>Here is the same problem in Why3 syntax:</p>
<pre><code>module A
  use HighOrd
  use import int.Int
  use import int.EuclideanDivision
  use import real.RealInfix
  use import real.FromInt
  type list &#39;a = Nil2 | Cons2 &#39;a (list &#39;a)
  function append (xs : list &#39;a) (ys : list &#39;a) : list &#39;a =
    match xs with
      | Nil2 -&gt; Nil2 : list &#39;a
      | Cons2 x zs -&gt; Cons2 x (append zs ys)
    end
  (* append (Nil2) ys = Nil2 : list &#39;a
     append (Cons2 x zs) ys = Cons2 x (append zs ys) *)
  goal x0 : forall xs : list &#39;a . (append xs (Nil2 : list &#39;a)) = xs
end</code></pre>
<h3 id="example-higher-order-functions">Example: Higher-order functions</h3>
<p>This is an example property about mapping functions over lists:</p>
<pre><code>(declare-datatype
  list (par (a) ((nil) (cons (head a) (tail (list a))))))
(define-fun-rec
  map
  (par (a b) (((f (=&gt; a b)) (xs (list a))) (list b)))
  (match xs
    ((nil (_ nil b))
     ((cons y ys) (cons (@ f y) (map f ys))))))
(prove
  (par (a b c)
    (forall ((f (=&gt; b c)) (g (=&gt; a b)) (xs (list a)))
      (= (map (lambda ((x a)) (@ f (@ g x))) xs) (map f (map g xs))))))</code></pre>
<p>Lambdas are introduced much like lets, with an identifier list with explicit types. Note that the function spaces are a family of types, with different arities. Thus, for some types <code>a</code>, <code>b</code> and <code>c</code>, there is a type <code>(=&gt; a b c)</code>, which is different from its curried version <code>(=&gt; a (=&gt; b c)</code>. Lambdas for the first type are constructed with <code>lambda ((x a) (y b)) ...</code>, and for the second with <code>lambda ((x a)) (lambda ((y b)) ...)</code>. To apply a lambda, you explicitly use the <code>@</code> function, which also come at a family of types: <code>((=&gt; a b) a) b</code>, <code>((=&gt; a b c) a b) c</code>, and so on.</p>
<p>Partial application is not supported, i.e. if you have a function <code>f</code> with type <code>(=&gt; int int int)</code>, the application <code>(f 1)</code> is invalid, and should be written with an explicit lambda: <code>(lambda ((x int)) (f 1 x))</code>. The reason why this is important is because SMT LIB supports polyvariadic functions, like <code>and</code>, and <code>+</code>. For example, if (implicit) partial application was allowed, the expression <code>(+ 1 2)</code> could mean <code>3</code> or <code>(lambda ((x int)) (+ 1 2 x))</code>, or a function with higher arity.</p>
<p>In some cases, higher order functions can be removed with specialisation, like in the example above. They can always be removed by defunctionalisation, which is implemented in our tool chain. This pass transforms the above program into this:</p>
<pre><code>(declare-sort fun1 :lambda 2)
(declare-datatype
  list (par (a) ((nil) (cons (head a) (tail (list a))))))
(declare-fun apply1 :lambda (par (a b) (((fun1 a b) a) b)))
(declare-fun
  lam :lambda (par (a b c) (((fun1 b c) (fun1 a b)) (fun1 a c))))
(define-fun-rec
  map
  (par (a b) (((f (fun1 a b)) (xs (list a))) (list b)))
  (match xs
    ((nil (_ nil b))
     ((cons y ys) (cons (apply1 f y) (map f ys))))))
(assert
  :definition :lambda
  (par (a b c)
    (forall ((f (fun1 b c)) (g (fun1 a b)) (x a))
      (= (apply1 (lam f g) x) (apply1 f (apply1 g x))))))
(prove
  (par (a b c)
    (forall ((f (fun1 b c)) (g (fun1 a b)) (xs (list a)))
      (= (map (lam f g) xs) (map f (map g xs))))))</code></pre>
<p>Here, <code>=&gt;</code> with one argument is replaced with <code>fun1</code>, <code>@</code> with one argument is replaced with <code>apply1</code>. The lambda in the property has become a new function, <code>lam</code>, which closes over the free variables <code>f</code> and <code>g</code>.</p>
<h3 id="todo">TODO</h3>
<p>This document does not yet cover mutual recusion (over data types or over functions), or partial branches and partiality.</p>
<h3 id="references">References</h3>
</div>
</body>
</html>
