<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="base-min.css" rel="stylesheet"/>
<link href="style.css" rel="stylesheet"/>
<title>TIP Format</title>
</head>
<body>
<div class="header">
<h1>TIP Format</h1>
</div>
<div class="content">
<p>This document contains the <a href="index.html">TIP</a> format, which is an extension of <a href="http://smt-lib.org">SMT-LIB</a> for expression inductive problems. The grammar of the format can also be viewed as <a href="bnf.html">BNF</a>.</p>
<!--
### Scope of the benchmark suite

We want the benchmark suite to focus exclusively on problems that need
induction. Functional programs that don't use inductive data types
probably fit better elsewhere. Also, although we support higher-order
functions and quantification over functions, problems that need a lot of
higher-order reasoning (e.g.Â synthesis of functions) are probably better
suited for THF.

### Criteria

When designing our language extensions, we had these criteria in mind:

1.  The problem format should not look like an encoding: features such
    as data types and pattern matching should be supported natively
    rather than encoded. We should preserve as much information as
    possible from the input problem in case it's useful to a prover.
2.  As far as possible, the syntax should be compatible with SMT-LIB. So
    we do not introduce new features just for the sake of it. We are
    however incompatible with SMT-LIB whenever it's needed to avoid
    breaking the first criterion.
3.  The format should be accessible: easy to understand and easy for
    other tools to use. We have written a tool which removes some of the
    advanced features (such as higher-order functions) from problems to
    help provers that don't support those features.
-->
<h3 id="differences-between-tip-and-smt-lib-2.6">Differences between TIP and SMT-LIB 2.6</h3>
<p>Our ambition is to keep TIP as close to SMT-LIB as possible. However, there are still a few incompatibilities:</p>
<ul>
<li>TIP allows polymorphism and type variables in function definitions. SMT-LIB only allows polymorphism in datatype definitions.</li>
<li>TIP allows higher-order functions, while SMT-LIB does not.</li>
<li>TIP allows partial functions. SMT-LIB does not.</li>
<li>For convenience, TIP has a special command <code>prove</code> for stating a goal to prove. This allows us to state several subgoals to be proved as separate proof attempts, in one file.</li>
<li>TIP uses a different syntax for annotations than SMT-LIB.</li>
</ul>
<p>The <a href="http://github.com/tip-org/tools">TIP tools</a> can convert TIP files not compatible with SMT-LIB 2.6 to valid SMT-LIB syntax (use the command <code>tip --smtlib myTIPfile.smt2</code>). This includes monomorphisation to remove type variables, removal of lambdas, completion of partial functions, removal of annotations and a translation pass which remove the <code>prove</code> statement and replaces them with valid SMT-LIB syntax using push/pop.</p>
<h3 id="example-datatypes-match-expressions-and-recursion">Example: Datatypes, match-expressions and recursion</h3>
<p>This example specifies the commutativity of plus over natural numbers:</p>
<pre><code>(declare-datatype Nat ((Zero) (Succ (pred Nat))))
(define-fun-rec
  plus
  ((x Nat) (y Nat)) Nat
  (match x
    (((Succ n) (Succ (plus n y)))
     (_ y))
(prove (forall ((n Nat) (m Nat)) (= (plus n m) (plus m n))))</code></pre>
<p>The syntax should be familiar to users of SMT-LIB. Natural numbers are defined with <code>declare-datatype</code>, and the function is declared using <code>define-fun-rec</code>. Both are part of the <a href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.6-r2017-07-18.pdf">SMT-LIB v2.6 standard</a>. We define <code>plus</code> rather than axiomatising it because, if the problem is from a functional program, we want to be explicit about which axioms are function definitions.</p>
<!-- Some provers like to distinguish between axioms and conjectures, and in -->
<!-- many inductive problems we have a distinguished conjecture. Following -->
<!-- our principle not to throw away information from the input problem, -->
<p>TIP has a <code>prove</code> construct which declares the goal, akin to <code>conjecture</code> in TPTP, or <code>goal</code> in Why3. It is not part of SMT-LIB. If the problem uses <code>prove</code> only once, then <code>(prove p)</code> means the same as <code>(assert (not p))</code>. If <code>prove</code> is used several times, it indicates that there are several goals which must all be proved.</p>
<!-- means the same as `(assert (not p))`, except that it marks `p` as a goal. -->
<!-- The `prove` construct seen above identifies the goal, and is not part of SMT-LIB. -->
<!-- The declaration `(prove p)`  -->
<!-- It can easily be removed by the TIP tool: XXXX how? -->
<!--     (declare-datatype Nat ((Zero) (Succ (pred Nat)))) -->
<!--     (define-fun-rec -->
<!--       plus -->
<!--       ((x Nat) (y Nat)) Nat -->
<!--       (match x -->
<!--         ((Zero y) -->
<!--          ((Succ n) (Succ (plus n y)))))) -->
<!--     (assert (not (forall ((n Nat) (m Nat)) (= (plus n m) (plus m n))))) -->
<p>The tool can also translate the example to Why3 syntax. It then looks like this:</p>
<pre><code>module A
  use HighOrd
  use import int.Int
  use import int.EuclideanDivision
  use import real.RealInfix
  use import real.FromInt
  type nat = Zero | Succ (nat)
  function plus (x : nat) (y : nat) : nat =
    match x with
      | Zero -&gt; y
      | Succ n -&gt; Succ (plus n y)
    end
  (* plus (Zero) y = y
     plus (Succ n) y = Succ (plus n y) *)
  goal x0 : forall n : nat, m : nat . (plus n m) = (plus m n)
end</code></pre>
<!--

### Complaints

(Data type declarations are already parametric, but the syntax is a bit broken.
It does not support declaring mutually recursive datatypes that differ in the amount of
type arguments.)

It is a bit broken because you have to first define all the signatures, and then the bodies.

-->
<h3 id="example-polymorphism">Example: Polymorphism</h3>
<p>TIP also supports polymorphism. Here is an example showing the right identity of append over polymorphic lists:</p>
<pre><code>(declare-datatype
  list (par (a) ((nil) (cons (head a) (tail (list a))))))
(define-fun-rec
  append
  (par (a) (((xs (list a)) (ys (list a))) (list a)))
  (match xs
    ((nil (_ nil a))
     ((cons x zs) (cons x (append zs ys))))))
(prove
  (par (a) (forall ((xs (list a))) (= (append xs (_ nil a)) xs))))</code></pre>
<p>We allow polymorphic datatypes, declarations and assertions using the syntactic form <code>(par (A) ...)</code> to quantify over the type variable <code>A</code>. Only rank-1 polymorphism is supported. Note that TIP allows both polymorphic datatypes and polymorphic functions, unlike SMT-LIB 2.6, which only allows it in datatype definitions.</p>
<!--
suggested in @smtlam, which is currently waiting to be merged
into CVC4 (@cvc4parPR). This syntax uses the syntactic form
`(par (A) ...)` to quantify over the type variable `A`. Only rank-1
polymorphism is supported.
-->
<p>Expressions can be annotated with their type with the <code>as</code> keyword. When the type of a function application is not fully specified by only looking the types of its arguments, the problem must use <code>as</code> to specify the type.</p>
<p>Polymorphism can be removed by specialising the program at some ground types, but this is not necessarily complete. Another method is to encode typing information over monomorphic terms. We plan to add techniques for this to the TIP toolchain. For now, provers must natively support polymorphism if they want to solve polymorphic problems.</p>
<p>When translating <code>assert-not</code> into <code>assert</code>, any polymorphic type variables are Skolemised:</p>
<pre><code>(declare-sort sk :skolem 0)
(declare-datatype
  list (par (a) ((nil) (cons (head a) (tail (list a))))))
(define-fun-rec
  append
  (par (a) (((xs (list a)) (ys (list a))) (list a)))
  (match xs
    ((nil (_ nil a))
     ((cons x zs) (cons x (append zs ys))))))
(assert
  (not (forall ((xs (list sk))) (= (append xs (_ nil sk)) xs))))</code></pre>
<p>Here is the same problem in Why3 syntax:</p>
<pre><code>module A
  use HighOrd
  use import int.Int
  use import int.EuclideanDivision
  use import real.RealInfix
  use import real.FromInt
  type list &#39;a = Nil2 | Cons2 &#39;a (list &#39;a)
  function append (xs : list &#39;a) (ys : list &#39;a) : list &#39;a =
    match xs with
      | Nil2 -&gt; Nil2 : list &#39;a
      | Cons2 x zs -&gt; Cons2 x (append zs ys)
    end
  (* append (Nil2) ys = Nil2 : list &#39;a
     append (Cons2 x zs) ys = Cons2 x (append zs ys) *)
  goal x0 : forall xs : list &#39;a . (append xs (Nil2 : list &#39;a)) = xs
end</code></pre>
<h3 id="example-higher-order-functions">Example: Higher-order functions</h3>
<p>This is an example property about mapping functions over lists:</p>
<pre><code>(declare-datatype
  list (par (a) ((nil) (cons (head a) (tail (list a))))))
(define-fun-rec
  map
  (par (a b) (((f (=&gt; a b)) (xs (list a))) (list b)))
  (match xs
    ((nil (_ nil b))
     ((cons y ys) (cons (@ f y) (map f ys))))))
(prove
  (par (a b c)
    (forall ((f (=&gt; b c)) (g (=&gt; a b)) (xs (list a)))
      (= (map (lambda ((x a)) (@ f (@ g x))) xs) (map f (map g xs))))))</code></pre>
<p>Lambdas are introduced much like lets, with an identifier list with explicit types. Note that the function spaces are a family of types, with different arities. Thus, for some types <code>a</code>, <code>b</code> and <code>c</code>, there is a type <code>(=&gt; a b c)</code>, which is different from its curried version <code>(=&gt; a (=&gt; b c)</code>. Lambdas for the first type are constructed with <code>lambda ((x a) (y b)) ...</code>, and for the second with <code>lambda ((x a)) (lambda ((y b)) ...)</code>. To apply a lambda, you explicitly use the <code>@</code> function, which also come at a family of types: <code>((=&gt; a b) a) b</code>, <code>((=&gt; a b c) a b) c</code>, and so on.</p>
<p>Partial application is not supported, i.e.Â if you have a function <code>f</code> with type <code>(=&gt; int int int)</code>, the application <code>(f 1)</code> is invalid, and should be written with an explicit lambda: <code>(lambda ((x int)) (f 1 x))</code>. The reason why this is important is because SMT LIB supports polyvariadic functions, like <code>and</code>, and <code>+</code>. For example, if (implicit) partial application was allowed, the expression <code>(+ 1 2)</code> could mean <code>3</code> or <code>(lambda ((x int)) (+ 1 2 x))</code>, or a function with higher arity.</p>
<p>In some cases, higher order functions can be removed with specialisation, like in the example above. They can always be removed by defunctionalisation, which is implemented in our tool chain. This pass transforms the above program into this:</p>
<pre><code>(declare-sort fun1 :lambda 2)
(declare-datatype
  list (par (a) ((nil) (cons (head a) (tail (list a))))))
(declare-fun apply1 :lambda (par (a b) (((fun1 a b) a) b)))
(declare-fun
  lam :lambda (par (a b c) (((fun1 b c) (fun1 a b)) (fun1 a c))))
(define-fun-rec
  map
  (par (a b) (((f (fun1 a b)) (xs (list a))) (list b)))
  (match xs
    ((nil (_ nil b))
     ((cons y ys) (cons (apply1 f y) (map f ys))))))
(assert
  :definition :lambda
  (par (a b c)
    (forall ((f (fun1 b c)) (g (fun1 a b)) (x a))
      (= (apply1 (lam f g) x) (apply1 f (apply1 g x))))))
(prove
  (par (a b c)
    (forall ((f (fun1 b c)) (g (fun1 a b)) (xs (list a)))
      (= (map (lam f g) xs) (map f (map g xs))))))</code></pre>
<p>Here, <code>=&gt;</code> with one argument is replaced with <code>fun1</code>, <code>@</code> with one argument is replaced with <code>apply1</code>. The lambda in the property has become a new function, <code>lam</code>, which closes over the free variables <code>f</code> and <code>g</code>.</p>
<h2 id="eliminating-stuff">eliminating stuff</h2>
<p>TIP also allows the user to define their functions in a more traditional SMT-LIB syntax, using if-then-else with discriminator and projector functions (in this case <code>is-Nat</code> and <code>pred</code>). The TIP tool is able to translate between these syntaxes. Here is how the example above looks with match removed:</p>
<pre><code>(declare-datatype Nat ((Zero) (Succ (pred Nat))))
(define-fun-rec
  plus
  ((x Nat) (y Nat)) Nat (ite (is-Succ x) (Succ (plus (pred x) y)) y))
(prove (forall ((n Nat) (m Nat)) (= (plus n m) (plus m n))))</code></pre>
<h3 id="todo">TODO</h3>
<p>This document does not yet cover mutual recusion (over data types or over functions), or partial branches and partiality.</p>
<h3 id="references">References</h3>
</div>
</body>
</html>
